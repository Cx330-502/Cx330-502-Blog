---
title: LLVM 中间代码生成 跳转
date: 2023-11-11 23:48:17
updated: 2023-11-11 23:48:20
tags:
  - LLVM
  - CPP
  - C
  - 编译
  - 跳转
categories: 编译
keywords:
  - LLVM
  - CPP
  - C
  - 编译
  - 跳转
description: 编译实验 C 语言生成 LLVM 目标代码， if、for、短路求值跳转
top_img:
comments:
cover:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax: true
katex:
aplayer:
highlight_shrink:
aside:
abcjs:
---

跳转感觉是整个 LLVM 中间代码生成中最难的一部分了，总共三个小部分 `if` 跳转、`cond` 跳转、 `for` 跳转，其中又以 `cond` 跳转最难，接下来按照顺序分析每个部分。

### if 跳转

在 SysY 中，`if` 语句文法如下：
$$
\text{' if ' '(' Cond ')' Stmt [ 'else' Stmt ]}
$$
用图表表示如下：

{% mermaid %}
graph TD
	A(Cond)
	B(Stmt1)
	C(Stmt2)
	D(Basic)
A --Cond = 1---> B
A --Cond=0且else存在---> C
A --Cond=0且else不存在---> D
B --> D
C --> D
{% endmermaid %}

也就是这里的跳转有如下几种情况：

+ `if` 条件为真时，跳转到 `Stmt1`
+ `if` 条件为假且 `else` 存在时，跳转到 `Stmt2`
+ `if` 条件为假且 `else` 不存在时，跳转到 `Basic` （即下一条正常语句）
+ `Stmt2` 执行结束跳转到 `Basic` 
+ `Stmt1` 执行结束跳转到 `Basic` 

从跳转的目标来看，这里需要三个 `label` 分别指向  `Stmt1` 、 `Stmt2` 、 `Basic` 。

这里出现了第一个**坑**，如果在前面的代码生成中都使用了数字作为虚拟寄存器代号，那么我**强烈建议**改成用字符串编号。为什么呢？

在按照顺序对 `if` 语句进行代码生成时，按照有 `else` 的情况，那么就需要在 `Stmt1` 的结尾和 `Stmt2` 的结尾分别跳转到 `Basic` 块。

+ 如果等 `Stmt1` 和 `Stmt2` 完全生成结束了才开始开始对 `Basic` 开始编号，那么 `Stmt1` 的结尾和 `Stmt2` 的结尾处的跳转语句就无从处理
+ 而如果先决定下来了 `Basic` 的编号，按照虚拟寄存器数字代号的要求，label 的顺序必须按照数字的顺序，也就是说很可能需要先生成 `Basic` 块的代码，再去处理 `Stmt1` 和 `Stmt2` ，这显然过于繁琐。

因此**强烈建议**改成用字符串编号，其实很好改，在编号前面加个字母就好了（doge）。

至于 `if` 跳转的代码怎么生成，其实是非常简单的，按照源代码按顺序生成 LLVM 代码即可：

```cpp
int stmt1_label = curReg++;
int stmt2_label = curReg++;
int basic_label = curReg++;
if(存在else){
    cout<<br i1 %cond label stmt1_label, label stmt2_label<<endl；
}else{
    cout<<br i1 %cond label stmt1_label, label basic_label<<endl；
}
//处理Stmt1
cout<<endl<<stmt1_label:<<endl；
generate_stmt1;
cout<<br label basic_label<<endl;
//处理else
if(存在else){
	cout<<endl<<stmt2_label:<<endl；
	generate_stmt2;
	cout<<br label basic_label<<endl;
}

cout<<endl<<basic_label:<<endl
//生成接下来的代码
```

当然啦，可能会有人疑惑，这不是只解决了一层的 `if` 吗，多层嵌套呢？

其实是一样的~~~

{% mermaid %}
graph TD
	A(Cond)
	B(Stmt1)
	C(Cond2)
	D(Basic)
	E(Stmt2)
	F(Stmt3)
	G(Basic2)
A --Cond=1---> B
A --Cond=0且else存在---> C
A --Cond=0且else不存在---> D
B --> D
C --Cond2=1---> E
C --Cond=0且else存在---> F
C --Cond=0且else不存在---> G
E --> G
F --> G
G --> D
{% endmermaid %}

跳转到 `Basic` 的语句最终会被添加到 `Basic2` 的末尾，而跳转到 `Basic2` 的语句则会根据之前的程序被添加到每个分支的末尾。

因此，上面的伪代码就已经很好的解决了 `if` 所有的跳转问题，但是难点短路求值还没开始呢😏😏😏。

### 短路求值

上面并没有直接的讨论 `if` 的判断条件 `Cond` 。事实上，根据语法树对 `Cond` 求值并不难，甚至和常量表达式一样非常简单，但是烦就烦在短路求值：

```cpp
int num = 0;
if ( 1 || num++){
    std::cout<< num << std::endl;
}
```

此处输出的 `num` 值是多少呢？但凡有点基础的都知道是 0 ，因为当条件语句的一部分已经能够确定整体值的时候，就不会再去计算剩下的部分。

从理论上来说，这个短路求值的操作是为了提升性能，毕竟能少算一部分。~~那么从理论上来说，我不要这部分性能直接全算不就行了嘛。怎么会有人在条件语句里改变值啊淦~~

所以，出于我们提高性能的伟大目的，让我们来看一看这个短路求值。
